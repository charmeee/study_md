#cs

> 프로그램을 설계할 때 발생했던 문제점들을 객체 간의 상호 관계등을 이용하여 해결할 수 있도록 하나의 규약 형태로 만들어 놓은것

## 싱글톤 패턴
하나의 클래스에 하나의 인스턴스, 데이터베이스 연결 모듈에 많이 사용

```js
//원리 constructor는 암묵적으로 this를 반환.
class SingletonA{
	 constructor( ) {
		 if(!Singleton.instance){
			 Singleton.instance = this
		 }
		 return Singleton.instance
	 }
	 getInstance(){
		 return this.instance
	 }
}

class SingletonB {
	static instance
	constructor() {
	    if (instance) return instance;
	    instance = this;
  }
}

const singleton1 = new Singleton();
const singleton2 = new Singleton();

const a1 = new Singleton();
const a2 = new Singleton();
console.log(a1===a2) // true
```

static은 클래스에 종속되어 있는 변수가 맞긴한데  인스턴스는 여러개 생성된다. 고로 싱글톤이라고 할 수 없다.

node.js에서 mysql과 mongodb의 라이브러리에서 Connect할때 때 이러한 패턴을 실제로 사용한다.
```js
const URL = 'dburl';
const createConnection = url => ({"url":url});

class DB{
	constructor(url){
		if(!DB.instance){
			DB.instance = createConnection(url);
		}
		return DB.instance;
	}
	connect(){
		return this.instance
	}
}

const a = new DB(URL);
const b = new DB(URL);

console.log(a===b);//true
```

#### 장점
- 인스턴트 생성 비용이 줄고 자원을 공유함.
- 데이터베이스 또는 로그 연결 객체와 같이 애플리케이션 전체에서 공통으로 사용되는 리소스에 대해 일관된 접근 방식 제공 가능
- 애플리케이션 전역에서 객체에 접근할 수 있으므로, 별도의 파라미터 전달이나 의존성 주입과 같은 과정이 필요없다.
#### 단점
- 의존성이 커짐(=모듈간의 결합을 강하게). -> 단위 테스트에 걸림돌
- 멀티스레드 환경처럼 다수의 클라이언트가 동시에 접근할 때 발생하는 객체의 상태 변화에 유의해야 함. 이런 환경에서 싱글턴 객체의 동기화가 보장되지 않는다면, 이에 의존하는 코드에 다양한 오류를 발생시킬 수 있음.
https://seongjin.me/woowacourse-three-design-patterns-in-javascript/

=> 해결 방법! 의존성주입 [[의존성 주입]]


## 팩토리패턴

>객체 생성부분을 떼어내 추상화한 패턴
>상위 클래스에서 중요한 뼈대를 결정하고 하위클래스에서 객체생성에 대한 구체적인 내용을 결정


