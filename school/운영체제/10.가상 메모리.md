> 사용자 논리 메모리와 물리 메모리의 분리
- 프로세스는 필요한 부분만 메모리에 올려서 실제로 메모리(물리주소 공간)에 올라가는 프로세스의 크기를 최소화 시키면 됨
	- 나머지는 논리주소공간에 올림
- 프로세스들이 연속된 물리적 메모리 공간처럼 여기게 만들 수 있음
- 실제보다 많은 메모리를 사용 가능하게 함

## Paging
외부단편화 방지 & compaction의 필요성 제거
![](assets/9.%20메인%20메모리%20할당-20240606203102092.png)

- Frame : 물리 메모리를 일정된 한 크기로 나눈 블록
- Page : 가상 메모리를 일정된 한 크기로 나눈 블록
- page table : 물리주소와 가상주소를 메핑하는 테이블
	- 메인메모리에 유지됨
	- Page-table base register (PTBR)  : 페이지 테이블을 가르킨다
	- Page-table length register (PTLR) : 페이지테이블크기를지시한다.
- 둘의 크기는 같아야함

### 주소 변환
![](assets/9.%20메인%20메모리%20할당-20240606204114530.png)
- p : page number - 페이지의 물리 메모리 시작주소를 저장
	- 해당 페이지가 할당되는 프레임의 시작주소
	- 페이지 테이블의 인덱스임
- d : page offset - 해당 페이지 내부에 데이터의 인덱스
- if 논리주소공간 크기=2^m and 한페이지 크기=2^n,
	- p = m-n
	- d = n
![](assets/9.%20메인%20메모리%20할당-20240606204246325.png)
#### Free Frames
- 빈프레임을 빈프래임 리스트에서 정보를 저장하고 있다.
- 할당할때 빈프래임리스트에서 목록을 보고 할당한다.

### 빠른 메모리 접근
하드웨어 캐쉬로 가능하다
- associative(연관) 메모리
	- 병렬 검색
- TLBs(translation look-aside buffers)
먼저 연관 메모리나 TLBs에 있는지 확인하고 있으면 (hit하면) 바로 물리주소로 변환하고 아니면 페이지 테이블을 확인한다.
##### 유효접근 시간(Effectve Acess Time)
연관 메모리 검색 시간 = at
적중률 = h
메모리 접근 시간 : mt
EAT = (mt+at)h + (2mt+at)(1-h)

### 메모리 보호
- 보호비트 : 각프레임 별로 읽고 쓰기 등 권한을 표시
- 유효-무효 비트 : 페이지 테이블의 각 항목에 포함됨
	- valid : 연관 페이지가 논리주소 공간에속함 = 합법적
	- invalid : 페이지가 논리주소공간에 존재
	- or PTLR을 사용
- 보호 위한시 커널로 트랩인터럽트를 발생

### 페이징 메모리 구조
#### 계층적페이징(Hierarchical Paging)
- 논리주소공간을 여러 페이지 테이블로 나눔
-  페이지테이블을 다시 페이징
ex) two level paging
![](assets/10.가상%20메모리-20240607161248434.png)
	if page 크기 1k and 32bit기기,
		page offset(d) = 10(2^10이니까)
		page no(p) = 22
		page no에서 페이지가 두개기때문에 번호가 다시 2개로 나뉜다
		p1(outer) no = 12 , p2(inner) offset = 10
	forward-mapped page table 라고함
#### 해시페이지테이블(Hashed Page Tables)
![](assets/10.가상%20메모리-20240607163640658.png)
- 가상페이지번호가 페이지 테이블로 해시됨
	- 번호를 사용하여 체인을 검색
- 즉 각 페이지 테이블은 같은 위치로 해싱되는 원소 체인을 가지고있다
- 원소 : 가상페이지 번호, 매핑된 프레임값, 다음원소를 가리키는 포인터를 저장한다
- 64bit주소를 위해 변형된 방식을 클러스터 페이지 테이블이라함
#### 역페이지테이블(Inverted Page Tables)

## Segmentation
사용자 관점의 메모리 관리 기법
- 가상메모리를 서로 크키가 다른 논리적단위인 세그먼트로 분할하고 메모리를 할당하여 실제 메모리 주소로 변환
- 각 세그멘트는 연속적인 공간에 저장되어 있음
- 세그먼트들의 크기가 다르기 때문에 미리 분할할 수 없고 메모리에 적재될 때 빈공간을 찾아 할당