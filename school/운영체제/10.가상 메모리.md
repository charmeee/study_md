> 사용자 논리 메모리와 물리 메모리의 분리
- 프로세스는 필요한 부분만 메모리에 올려서 실제로 메모리(물리주소 공간)에 올라가는 프로세스의 크기를 최소화 시키면 됨
	- 나머지는 논리주소공간에 올림
- 물리적으로는 불연속 But 논리적으로 연속
	- 프로세스들이 연속된 물리적 메모리 공간처럼 여기게 만들 수 있음
- 실제보다 많은 메모리를 사용 가능하게 함
- 적재 스왑프로세스에 필요한 I/O감소
#### 가상메모리 공간
![200](assets/10.가상%20메모리-20240607165620996.png)
둘사이의 미사용공간을 Hole로 두어 사용가능하게함

## Paging
외부단편화 방지 & compaction의 필요성 제거
![400](assets/9.%20메인%20메모리%20할당-20240606203102092.png)

- Frame : 물리 메모리를 일정된 한 크기로 나눈 블록
- Page : 가상 메모리를 일정된 한 크기로 나눈 블록
- page table : 물리주소와 가상주소를 메핑하는 테이블
	- 메인메모리에 유지됨
	- Page-table base register (PTBR)  : 페이지 테이블을 가르킨다
	- Page-table length register (PTLR) : 페이지테이블크기를지시한다.
- 둘의 크기는 같아야함

### 주소 변환
![500](assets/9.%20메인%20메모리%20할당-20240606204114530.png)
- p : page number - 페이지의 물리 메모리 시작주소를 저장
	- 해당 페이지가 할당되는 프레임의 시작주소
	- 페이지 테이블의 인덱스임
- d : page offset - 해당 페이지 내부에 데이터의 인덱스
- if 논리주소공간 크기=2^m and 한페이지 크기=2^n,
	- p = m-n
	- d = n
![400](assets/9.%20메인%20메모리%20할당-20240606204246325.png)
#### Free Frames
- 빈프레임을 빈프래임 리스트에서 정보를 저장하고 있다.
- 할당할때 빈프래임리스트에서 목록을 보고 할당한다.

### 빠른 메모리 접근
하드웨어 캐쉬로 가능하다
- associative(연관) 메모리
	- 병렬 검색
- TLBs(translation look-aside buffers)
먼저 연관 메모리나 TLBs에 있는지 확인하고 있으면 (hit하면) 바로 물리주소로 변환하고 아니면 페이지 테이블을 확인한다.
##### 유효접근 시간(Effectve Acess Time)
연관 메모리 검색 시간 = at
적중률 = h
메모리 접근 시간 : mt
EAT = (mt+at)h + (2mt+at)(1-h)

### 메모리 보호

- 보호비트 : 각프레임 별로 읽고 쓰기 등 권한을 표시
- 유효-무효 비트 : 페이지 테이블의 각 항목에 포함됨
	- valid : 연관 페이지가 논리주소 공간에속함 = 합법적
	- invalid : 페이지가 논리주소공간에 존재
	- or PTLR을 사용
- 보호 위반시 커널로 트랩인터럽트를 발생

### 페이징 메모리 구조
#### 계층적페이징(Hierarchical Paging)
- 논리주소공간을 여러 페이지 테이블로 나눔
-  페이지테이블을 다시 페이징
ex) two level paging
![400](assets/10.가상%20메모리-20240607161248434.png)
	if page 크기 1k and 32bit기기,
		page offset(d) = 10(2^10이니까)
		page no(p) = 22
		page no에서 페이지가 두개기때문에 번호가 다시 2개로 나뉜다
		p1(outer) no = 12 , p2(inner) offset = 10
	forward-mapped page table 라고함
#### 해시페이지테이블(Hashed Page Tables)
![400](assets/10.가상%20메모리-20240607163640658.png)
- 가상페이지번호가 페이지 테이블로 해시됨
	- 번호를 사용하여 체인을 검색
- 즉 각 페이지 테이블은 같은 위치로 해싱되는 원소 체인을 가지고있다
- 원소 : 가상페이지 번호, 매핑된 프레임값, 다음원소를 가리키는 포인터를 저장한다
- 64bit주소를 위해 변형된 방식을 클러스터 페이지 테이블이라함
#### 역페이지테이블(Inverted Page Tables)
- 메모리 프레임마다 하나의 페이지 테이블 항목을 할당
- 프로세스 증가와 관계없이 크기가 고정된 페이지 테이블에 프로세스를 매핑하여 할당
- 논리주소에 pid를 추가하여 페이지테이블에서 인덱스로 찾는게아니라 pid를 검색해서 찾는다.
- 최소공간을 사용하지만 최악의 경우 테이블 전체탐색이 발생하여 성능 저하가 발생한다.


### Demand Paging(요구 페이징)
프로그램 실행동안 메모리를 적제하는 방법
- 적재시 프로세스 전체 또는 필요항 페이지일부만 메모리로 가져올 수있음
- Lazy swapper : 페이지가 필요해지기 전까지 메모리로 스왑하지않음
- Valid/Invalid Bit 사용 
	- 주소 변환중 유무효 비트가 i 면 페이지 폴트 발생![200](assets/10.가상%20메모리-20240607170542544.png)
#### Page Fault
![300](assets/10.가상%20메모리-20240607175805248.png)
- Invalid Page 참조시 MMU가 trap를 발생시킨다
- 이후 커널모드로 들어가고 Page Fault Handler가 실행된다
- 처리순서
	1. 물리 메모리에서 가용한 프레임을 찾음
	2. 디스크I/O 요청으로 해당 페이지 프레임을 스왑한다
	3. 페이지가 메모리이 있다는것을 표시하기위에 테이블을 제지정 한다 > 유효무효 비트 v로 변경
	4. 페이지 폴트 유발한 명령어를 다시 실행
- 오버해드가있다.. 다시실행해야함..
#### EAT(Effective Access Time)
p: page fault rate
s : swapout + swap in
m : memory access

EAT 
## Segmentation
>내부단편화 방지
>사용자 관점의 메모리 관리 기법
- 가상메모리를 서로 크키가 다른 논리적단위인 세그먼트로 분할하고 메모리를 할당하여 실제 메모리 주소로 변환
- 각 세그멘트는 연속적인 공간에 저장되어 있음
- 세그먼트들의 크기가 다르기 때문에 미리 분할할 수 없고 메모리에 적재될 때 빈공간을 찾아 할당
### 주소 변환
![400](assets/10.가상%20메모리-20240607165030721.png)
- 논리주소는 2tuple 로 구성
	- <segment-number, offset>
- 세그먼트 테이블 :2차원 물리주소를 매핑
	- base : 세그먼트가 위치하는 메모리 시작 물리주소
	- limit : 세그먼트 길이를 지정
	- 유효비트와 특권(권한)관련 정보가 포함된다.
	- 코드 공유는 세그먼트 수준에서 일어난다.
- STMR(Segment-table base register) : 세그먼트 테이블의 메모리 위치를 가르킴
- STLR(Segment-table length register) : 프로그램이 사용하는 세그먼트 개수를 나타냄

