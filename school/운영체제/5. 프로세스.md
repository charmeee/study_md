- 실행중인 프로그램이자 시스템안에서의 작업단위.
	- 프로그램 : passive entity
	- 프로세스 : active entity
	- 하나의 프로그램은 여러프로세스로 만들어질 수 있음
- 종료시 재활용 가능한 모든 자원을 반환 해야함.
- 프로세스는 PC(프로그램카운터)를 가진다
	- PC는 다음실행할 명령어 주소를 저장하는 곳
	- 단일스레드프로세스 : 하나의 PC가짐
	- 다중스레드프로세스 : 스레드마다 하나의 PC 가짐
- 일반적으로 프로세스는 프로세스 식별자(pid)를 이용하여 식별되고 관리됨
- CPU에 프로세스/스레드를 다중 배정함 > 병행성을 얻음
- 자원 처리량에 따른 종류
	- I/O-bound 프로세스 : cpu<io에 시간을 더 많이 소모함.
	- CPU-bound 프로세스 : 반대.
### 프로세스 상태
![[assets/스크린샷 2024-04-16 오전 11.06.40.png]] 
- new : 프로세스가 생성중인 상태
- ready : 프로세스가 스케줄러에 의해 cpu사용권을 받기 위하여 대기하고 있는 상태
- running: cpu에서 프로세스가 실행중인 상태
- waiting  : 프로세스가 어떤 사건이 일어나기를 대기하고 있는 상태

### 프로세스 메모리 할당
![[assets/Pasted image 20240416205457.png|300]]
- text(=code)영역
	- 실행할 프로그램의 코드(명령어의 집합)가 저장됨
- data 영역
	- 전역 변수와 정적 변수가 저장됨
- stack 영역
	- 잠시 사용되었다가 사라지는 데이터(매개변수,리턴값,지역변수 등..)를 저장
	- 함수 호출시 할당, 반환시 소멸 , 컴파일 타임에 크기 결정
- heap 영역
	- 동적 데이터 영역, 메모리 주소 값에 의해서만 참조됨
	- 런타임에 크기가 결정됨


### 스레드
프로세스 안의 제어 흐름
text(code) , data 영역의 자원을 공유한다.
![[assets/Pasted image 20240416213116.png]]
## 문맥 교환
cpu 레지스터 단위에서 일어남
### PCB
프로세스 제어 블록
이를  이용하여 문맥교환이 이뤄진다.
- 시간은 오버헤드지만 반드시 필요하다.
##### 저장하는 정보
- 프로세스 상태
- PC(프로그램 카운터): 다음에 실행할 명령어 주소
- CPU 레지스터 : 모든프로세스 관련 레지스터 내용
- CPU 스케줄링 정보 : 우선순위, 스케줄링 큐 포인터
- 메모리 관리 정보 : 프로세스에게 할당된 메모리
- 회계정보 : 사용된 CPU양 , 실행 후 경과된 클럭 타임, 시간제한 등
- I/O 상태정보 : 프로세스에게 할당된 I/O장치

#### 문맥 전환 과정
![[assets/스크린샷 2024-04-16 오후 9.27.24.png|400]]



## 프로세스 스케줄링
- 목적 : CPU 사용을 최대로 하는 것.
- CPU에서 실행할 프로세스를 선택하는 것
### 스케줄링 큐들
- job queue : 모든 프로세스가 올라가 있는 큐 (Long term)
- ready queue : 준비 상태에 있는 큐들이 올라가 있다 (short term)
- device queue : 입출력 장치마다 있는것,
#### 큐잉 다이어 그램
큐, 자원(원모양),프로세스의 이동 흐름을 나타냄
![[assets/스크린샷 2024-04-16 오후 9.47.34.png]]
process create 되고 나선 바로 job queue에 적재된다.
이 적재된것중에 ready queue 로 가는 것
순서 : create > job queue > ready queue

### 스케줄러
#### 단기 스케줄러 (= cpu 스케줄러) 
- 다음에 cpu에 할당될 프로세스를 선택한다
- 즉 준비큐에 있는 프로세스를 선택한다.
- ms 간격으로 호출 > 빨라야함
#### 장기 스케줄러 (= 잡 스케줄러)
- 준비큐로 이동할 프로세스를 선택한다.
- s, min 간격으로 호출
- 이 스케줄러가 다중프로그래밍 정도를 결정
- io bound 와 cpu bound프로세스가 고루 섞이도록 한다.
#### 중기 스케줄러
- 많은 프로세스가 있을때(= 다중프로그래밍 중일 때), 너무 많은 프로세스에게 메모리를 할당해 시스템 성능이 저하 되는 것을 방지하기 위함
- swaping 이용
	-  물리 메모리 공간이 부족해지면, 물리 메모리의 확장 개념으로 swap area를 사용하고 swap out 시켜 내보냄
	- 메모리 <-> 디스크

## 프로세스 연산
#### 프로세스 생성
부모 프로세스가 자식프로세스를 생성하는 것 (트리 구조를 형성)
##### 주소 공간
 - 자식은 부모와 주소공간을 공유한다.
 - 그 주소 공간을 복재한 후 그 공간에 프로그램을 적제
##### 옵션
- 자원 공유 옵션
	- 부모와 자식은 모든 자원을 공유한다.
	- ""  은 부분 집합을 공유한다
	- ""  은 자원을 공유하지 않는다
- 실행 옵션
	- 부모와 자식은 병행하게 실행된다
	- 부모는 자식이 종료될 때 까지 기다린다.

##### UNIX 예시
- fork() 시스템 콜이 새로운 프로세스를 생성  
    부모를 그대로 복사(OS data except PID + binary)  
    주소 공간 할당
- fork 다음에 이어지는 exec() 시스템 콜을 통해 새로운 프로그램을 메모리에 올림
#### 프로세스 종료
`exit()` 시스템 콜을 사용하여 삭제 요청을 함
종료된 후 자원은 os에 반환됨
##### 종료 제어
- `abort()` : 부모가 자식 프로세스 실행을 종료 (아래는 사용 예시)
	- 자식이 할당할 수 있는 자원보다 더 많은 자원을 할당한 경우
	- 자식에게 배정된 일이 더이상 필요치 않는 경우
	- 부모가 종료중에 있지만 os에서 부모가 먼저 종료한 자식프로세스의 실행을 허용하지 않는 경우
- wait() : 부모가 자식 프로세스의 종료를 기다림
	- 자식프로세스를 상태값을 반환
##### 좀비/고아프로세스
- 좀비 프로세스 : 자식이 부모보다 먼저 종료 되고  부모가 아직 `wait()` 호출을 하지 않은 프로세스(=즉 부모프로세스란소리)
	- wait를 통해 자식을 회수하지 않으면 자식이 사용하던 리소스를 회수 하지못함
	- 이상황을 방지하기위해 자식이 먼저 종료되더라도 최소한의 정보를 가지고 있음. 따라서 그이후에 wait호출하기만하면됨
- 고아 프로세스 : 부모가 자식보다 먼저 종료됨.(=즉 자식프로세스임)
	- 부모가 제거되어서 부모 pid가 init프로세스로 설정됨
	- init 프로세스가 wait을 대신 호출하여 리소스를 회수

## 프로세스 통신(IPC)
필요 이유 : 정보공유, 계산속도향상,모듈성, 편리 등..
모델

![[assets/스크린샷 2024-04-16 오후 10.43.47.png|400]]
### 공유메모리 모델(shared memory)
- 프로세스 사이에 공유되는 메모리 영역
- 해당 통신은 사용자 프로세스의 통제하에 이뤄짐(OS ㄴㄴ)
- 사용자프로세스가 접근시 서로 동기화할 수 있는 기법을 제공해야함
- 중개자 없이 곧바로 메모리 접근 가능 == 빠름
### 메세지 전달 모델(message passing)
- 공유 변수를 접근하지 않고 서로 통신
- OS(커널을 이용)가 메세지 전달 수단을 제공 , OS가 동기화 기법을 제공
- 연산
	- send
	- receive
- 직접 통신
	- 서로 상대방을 명시적으로 명명해야함
		- send(p,message),receive(Q,message)
	- 링크는 자동적으로 설정
	- 통신하는 프로세스 쌍에는 하나의 링크만 생성되고 존재한다.
	- 연결은 보통은 양방향이다.
- 간접통신
	- 메세지는 메일박스로 보내지고 수신된다
		- 각메일박스는 고유한 아이디를 가진다.
		- 프로세스는 서로 공유하는 메일박스를 통해 통신이 가능하다
		- send(A,message),receive(A,message)
	- 메일 박스 공유 : 누가 메세지를 수신하는가의 문제(송신자 입장)
		- 링크는 최대 두프로세스 사이에만 설정
		- 한번에 한 프로세스만 receive가능
		- 시스템이 임의로 수신자 선택, 송신자는 누가 수신자인지 통지
- 메세지 전달 방식
	- blocking 
		- 동기적
	- non-blocking
		- 비동기적
	- 송수신자 모두 blocking 방식일때 : rendezvous
- buffering(버퍼링)
	- 링크에 접속된 메시지 큐
	- zero capacity : 메세지를 큐에 저장 ㄴㄴ, 송신자는 수신자가 메세지 받을때 까지 기달(rendezvous)
	- bounded capacity : n개의 메세지를 저장할 수 있는 길이큐, 큐가 가득찰시 송신자는 대기
	- unbounded capacity : 무한개의 메시지를 저장할 수 있는 길이 큐, 송신자는 절대 대기하지않음

#### 메세지 전달모델 예
Socket
- ip주소와 포트번호로 정의됨
- 프로세스 식별하는 숫자가 포트번호
![[assets/스크린샷 2024-04-17 오후 1.39.28.png|300]]

원격 프로시저 콜(PRC)
- 별도의 원격 제어를 위한 코딩 없이 원격에서 함수나 프로시저를 실행 가능하게 하는 프로세스간 통신 기술
- stubs(스텁) : 서버 쪽 실제 프로시저에 상용하는 클라이언트 쪽 proxy
- 