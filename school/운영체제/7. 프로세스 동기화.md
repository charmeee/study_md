- 데이터의 일관성을 유지할 수 있게 해야한다
- 통신과정에서 생기는 생산자 - 소비자 문제를 해결해야한다.
## 임계영역 
임계 영역 : 공유하는 데이터에 접근하고 갱신할 수 있는 코드 영역
임계 영역 문제: 해당 영역에 하나의 프로세스만 있어야 한다.
**동기화 문제 해결 == 임계영역 문제 해결**
임계영역에는 진입영역(허가 받는), 퇴출영역, 나머지 영역이 있다
###  임계 영역 문제 해결을 위핸 3가지 필수 조건
1. 상호배제(mutual exclusion)
	- 프로세스 하나가 임계영역에서 실행 중이라면 다른프로세스는 임계영역에서  실행될 수 없다.
2. 진행(progress)
	- 현재 임계영역에서 실행되는 프로세스가 없고, 그 임계영역에 진입하려는 프로세스가 있다면
	- THEN, 임계영역에 들어올 다른 프로세스를 선택하는걸 무기한 연기할 수 없다.
3. 한정된 대기(bounded waiting)
	- 프로세스가 임계구역에 진입하려는 요청을 한 후 그 요청이 허용될 때 까지 다른 프로세스들의 진입 허용 횟수를 제한한다.

## 동기화 해결책

해결하기 위한 하드웨어도 제공되어야 함
- 단일 처리기
	- 실행중인 코드는 선점 없이 실행된다
	- 일반적으로 다중처리기 시스템에서는 너무 비효율적
- 특별한 원자적 하드웨어 명령을 제공
	- 원자성 : 인터럽트가 불가능한 연산 단위

이후 해결책은 소프트웨어 해결책
### peterson 해결책
전통적인 소프트웨어적인 해결책
- 두개의 변수(데이터)를 필요로 함
```java
//최대 2번째 프로세스까지 있음

boolean flag[2];
//flag[n]==true , n번째 프로세스가 임계구역으 사용하고 싶다
int turn;
//프로세스 차례, turn= n 이면 n번째 프로세스 차례
while(flag[n] && turn==n){
	//임계영역
	flag[n]=false;
	//remain 영역
}
```
해결안 증명 : https://yonghwankim-dev.tistory.com/265
다중프로그램 시스템에서 사용할 수없음

### Mutex Locks(=이진 세마포어)
- 세마포어 값이 0,1을가짐
- 임계구역을 보호하고 경쟁상태를 예방
- 임계구역 입장전 Lock을얻어야하고 퇴장시 Lock을 해제하여야함
#### 연산
- acquire() : lock을 얻음(입장)//wait이라고  표현할 수 있는듯
- release(): lock해제(퇴장)//signal이라고 표현할 수 있는 듯
- available :lock을얻을 수 있는가? 
#### 단점
- busy waiting 문제가 있음
	- lock을 얻을때 까지 계속 접근을 시도(이걸 spinlock이라함)

### semaphore
고수준 소프트웨어 도구들의 종류
Busy-waiting 하지않는 동기화 도구