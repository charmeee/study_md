- 데이터의 일관성을 유지할 수 있게 해야한다
- 통신과정에서 생기는 생산자 - 소비자 문제를 해결해야한다.
	- 생산자-소비자 문제(producer-consumer problem)는 여러 개의 프로세스를 어떻게 동기화할 것인가에 관한 고전적인 문제이다. 한정 버퍼 문제(bounded-buffer problem)라고도 한다.
	- https://copycode.tistory.com/67
## 임계영역 
임계 영역 : 공유하는 데이터에 접근하고 갱신할 수 있는 코드 영역
임계 영역 문제: 해당 영역에 하나의 프로세스만 있어야 한다.
**동기화 문제 해결 == 임계영역 문제 해결**
임계영역에는 진입영역(허가 받는), 퇴출영역, 나머지 영역이 있다
###  ==임계 영역 문제 해결을 위한 3가지 필수 조건==
1. 상호배제(mutual exclusion)
	- 프로세스 하나가 임계영역에서 실행 중이라면 다른프로세스는 임계영역에서  실행될 수 없다.
2. 진행(progress)
	- 현재 임계영역에서 실행되는 프로세스가 없고, 그 임계영역에 진입하려는 프로세스가 있다면
	- THEN, 임계영역에 들어올 다른 프로세스를 선택하는걸 무기한 연기할 수 없다.
3. 한정된 대기(bounded waiting)
	- 프로세스가 임계구역에 진입하려는 요청을 한 후 그 요청이 허용될 때 까지 다른 프로세스들의 진입 허용 횟수를 제한한다.

## 동기화 해결책

해결하기 위한 하드웨어도 제공되어야 함
- 단일 처리기
	- 실행중인 코드는 선점 없이 실행된다
	- 일반적으로 다중처리기 시스템에서는 너무 비효율적
- 특별한 원자적 하드웨어 명령을 제공
	- 원자성 : 인터럽트가 불가능한 연산 단위

이후 해결책은 소프트웨어 해결책
### peterson 해결책
전통적인 소프트웨어적인 해결책
- 두개의 변수(데이터)를 필요로 함
```java
//최대 2번째 프로세스까지 있음

boolean flag[2];
//flag[n]==true , n번째 프로세스가 임계구역으 사용하고 싶다
int turn;
//프로세스 차례, turn= n 이면 n번째 프로세스 차례
while(flag[n] && turn==n){
	//임계영역
	flag[n]=false;
	//remain 영역
}
```
해결안 증명 : https://yonghwankim-dev.tistory.com/265
다중프로그램 시스템에서 사용할 수없음
이외에도 Compare - and - Swap이라는 해결책이 있음
### Mutex Locks
- 임계구역을 보호하고 경쟁상태를 예방
- 임계구역 입장전 Lock을얻어야하고 퇴장시 Lock을 해제하여야함
- 뮤텍스는 오브젝트다
#### 연산
- acquire() : lock을 얻음(입장)
- release(): lock해제(퇴장)//signal이라고 표현할 수 있는 듯
- available :lock을얻을 수 있는가? 
#### 단점
- busy waiting 문제가 있음
	- lock을 얻을때 까지 계속 접근을 시도(이걸 spinlock이라함)

### ==semaphore==
고수준 소프트웨어 도구들의 종류
Busy-waiting 하지않는 동기화 도구
	how? 프로세스를 일시 정지하면됨 그리고 대기큐에 집어넣음
원자적 연산에 의해서만 접근 가능하다
동시에 여러 프로세스 접근 가능= 한정버퍼 문제 해결가능== 생산자 소비자 문제
([[생산자 소비자 문제]])
#### busy waiting semaphore
원자적 연산 : wait(입장하려는), signal(퇴장하려는)  사용
- binary semaphore
	- 값 0 대기 , 1이면 입장
	- mutex lock 대신 사용가능
- counting semaphore
	- 공유자원이 여러개일때 사용
#### non - busy waiting semaphore
##### 구현 방법
- 각 세모포에 대해 연관된 대기 큐가 있다.
	- 세마포어 값과 이 세마포에 대기하는 프로세스 리스트의 포인터를 저장한다.
- 프로세스를 세모포어와 연관된 대기 큐에넣고 프로세스 상태를 대기(waiting) 로  변경한다
##### 연산
- block : 대기큐에넣는다
- wakeup : 대기큐 프로세스중하나를 준비큐에 넣는다

#### 발생할 수 잇는 문제
- Deadlock : 한 프로세스만 야기할 수 있는 이벤트를 무한정 기다림 [[8. 프로세스 교착상태]]
	- 모두 wait상태일때 
	  ![[assets/Pasted image 20240417230303.png|300]]
- Starvation
	- 우선순위가 낮아서 자원을 계속 할당 받지 못하는 상태
- ==Priority Inversion(우선순위 역전)==
	- 높은 순위가 필요로 하는 lock(자원)을 낮은 우선순위의 프로세스가 가지고 있을때(lock을 얻어야 입장함)
	- 우선순위 상속 프로토콜로 해결

### ==프로세서 코어별 동기화 방법==
- 싱글코어 프로세서 : 원자적 연산(인터럽트를 금지함)들을 이용해서 해결할 수 있다. ex ) 세마포어
- 멀티코어 프로세서 : 모든 코어에서의 인터럽트 금지는 성능 저하를 발생한다. 따라서 spin lock이나 compare_and_swap을 사용한다.