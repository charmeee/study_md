- 프로그램이 실행되기 위해서는 메모리에 저장되 프로세스 내에 배치되어야함
- 메인메모리와 레지스터는 cpu가 직접 접근할 수 있는 유일한 저장장치
- 메모리 하드웨어는 주소 + 읽기요청 or  주소 + 데이터 쓰기 요청만 가능
- 메인 메모리 접근에는 많은 사이클이 필요하고 stall 이 발생한다
- 논리(logical)주소 = 가상(virtual)주소 = 재할당(relocatable) 주소
- Symbolic 주소 : 프로그래머가 코드에서 사용하는 상징적인 이름을 주소로 사용하는것

## 프로세스 수행과 메인메모리

- 프로그램실행되기 위해서 메모리에 저장되어 프로세스 안에 배치되어야함 (== 프로세스 수행할려면 메모리접근이 필요함)
### 메모리 공간 보호
- Base & limit 레지스터는 프로세스의 논리적(logical) 주소의 범위를 지정함
  ![](assets/9.%20메인%20메모리-20240605193111793.png)
	- base(== relocation )  레지스터: 프로세스의 시작 메모리 주소를 저장.
	- limit 레지스터: 프로세스가 사용할 수 있는 메모리 공간의 크기를 저
- CPU H/W는 사용자 모드에서 생성된 모든 주소를 레지스터와 비교해서  사용자 기준과 상한 범위에 속하는지 검사해야함
물리주소를 가지고있으면..
![](assets/9.%20메인%20메모리-20240606180135582.png)
논리주소를 가지고 있으면..
![](assets/9.%20메인%20메모리%20할당-20240606195750063.png)
## 메모리주소 바인딩(할당)
cpu가 만든 논리주소를 물리주소에 할당하는 것을 말함
#### 시점에 따른 바인딩
- Compile time
	- 상황 : 메모리 위치를미리 알고 있음
	- 절대주소(absolute)가 생성 될 수 있다.
- Load time
	- 상황 : 컴파일할 때 주소를 알 수 없음
	- 재배치 가능주소가 생성되어야 한다.
		- 후에 loader에 의해 재배치 주소가 절대주소로 변환
- Execution time
	- 상황 : 프로세스가 메모리 세그먼트 위치를 변경할 수 있음
	- 바인딩이 실행시간까지 연기됨
		- 주소 맵을 유지하기 위한 하드웨어 지원이 필요
	- 메모리참조가 일어날때 바인딩된다.
	- 현재 OS가 대부분 이방식 사용 
		- MMU(Memory Management Unit) 장치에 의해 논리 주소를 물리 주소로 변환
		- MMU는 논리주소 > 물리주소로 매핑하는 하드웨어 장치
		

### MMU 동작
#### Dynamic Relocation
프로세스에 의해 생성된주소 + 재배치(base) 레지스터 값을 더하여 요청
![300](assets/9.%20메인%20메모리%20할당-20240606192503073.png)

#### Dynamic Linking
프로세스 실행 중 필요할 때 라이브러리를 링크하는 방식 : 메모리 절약 가능, 유지보수 용이
- linking과 로더가 시스템라이브러리와 프로그램 코드를 결합하여 이진 프로그램 이미지가 생성
- 스텁이 상주 라이브러리 루틴의 위치를 찾기위해 사용됨
	- 자기자신을루틴의 주소로 대체하여 라이브러리 루틴실행
	- 상주 라이브러리 == **shared libraries**

### Swapping
![](assets/9.%20메인%20메모리%20할당-20240606194512337.png)
swap out :메인 메모리 > 보조 저장장치
swap in : 보조 저장 장치 > 메인 메모리
- 스왑시간의 대부분은 전송시간
- 디스크에 메모리이미지를 가진 ready-to-run 프로세스로 구성된 준비큐를 유지
- roll out, roll in : 우선순위 스케줄링 알고리즘에서 사용되는 스와핑의 변형
- 다음에 실행시킬 프로세스가 없다면 하나를 스왑아웃하나를 스왑인 해야함
	- 시간 : swap in 시간, swap out 시간 + 디스크 입력지연 * 2
- 현재 OS들은 수정버전을 사용
- 모바일에서는 사용 ㄴㄴ
	- ios는 자발적으로 메모리 반환을 요구
	- Android는 가용메모리가 적으면 앱 종료
		- 빠르게 재시작시킬 수 있도록 앱상태를 기록
	- 페이징은 지원한다

### 메모리 분할 할당
- 분할(Partitioning)
	- Fixed partition(고정분할)
	- Variable partition(가변분할)
- 분할 개수가 다중 프로그래밍 정도를 제한함
- hole : 가용 메모리 블록(=가용분할)
- 종료되는 프로세스는 자신의 분할을 반환하고 인접한 가용 분할과 합쳐짐
- 운영체제는 할당된 분할, hole의 정보를 유지한다.
#### hole을 찾는 알고리즘
 - First-fit(최소 적합) : 충분히 큰 최소의 hole을 할당
 - Best-fit(최적 적합) : 충분히 큰 가장 **작은** hole을 할당
	 - 크기 순으로 정렬되어 있지 않다면 리스트 전체를 탐색해야함
	 - 가장 작은 hole을 남김
 - Worst-fit(최악 적합) :  가장 큰 hole을 할당
	 - 크기 순으로 정렬되어 있지 않다면 리스트 전체를 탐색해야함
	 - 공간이용률 겁나게 안조음 
#### 단편화
- 내부 단편화 : 메모리를 할당 할 때 프로세스가 필요한 양보다 더 큰 메모리가 할당되어서 메모리 공간이 낭비되는 현상  ![](assets/9.%20메인%20메모리%20할당-20240606201117648.png)
- 외부 단편화 : 메모리가 할당 및 해제 작업의 반복으로 메모리 중간중간에 사용하지 않는 메모리가 생기고 이를 합쳤을 때는 메모리가 충분하지만 실제로는 할당할 수 없는 상황![](assets/9.%20메인%20메모리%20할당-20240606201149470.png)
- 해결 방법
	- compaction(압축) : 메모리 내용을 이동시켜 모든 가용메모리가 하나의 커다란 블록이 되도록 만듬
		- 재할당이 동적이고 실행시간에 완료될 때만 가능
		- 외부 단편화를 해결
	- paging and segmentation > 아래에 다룸

## 가상메모리(=논리메모리)
- 프로세스는 필요한 부분만 메모리에 올려서 실제로 메모리에 올라가는 프로세스의 크기를 최소화 시키면 됨
	- 나머지는 가상메모리에 올림
- 프로세스들이 연속된 물리적 메모리 공간처럼 여기게 만들 수 있음
- 실제보다 많은 메모리를 사용 가능하게함
### Paging
외부단편화 방지 & compaction의 필요성 제거
![](assets/9.%20메인%20메모리%20할당-20240606203102092.png)
 - Frame : 물리 메모리를 일정된 한 크기로 나눈 블록
 - Page : 가상 메모리를 일정된 한 크기로 나눈 블록
 - page table : 물리주소와 가상주소를 메핑하는 테이블
 - 둘의 크기는 같아야함
#### 주소 변환
![](assets/9.%20메인%20메모리%20할당-20240606204114530.png)![](assets/9.%20메인%20메모리%20할당-20240606204246325.png)