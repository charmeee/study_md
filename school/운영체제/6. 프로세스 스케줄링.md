
- CPU에서 실행할 프로세스를 선택하는 것
- 프로세스 실행은 cpu-i/o burst cycle(cpu 다음에 io)
### 목표
- CPU 사용을 최대화
	-  CPU Utilization = ∑ (Process time / period)
- 처리량 최대화
- 총처리 시간을 최소화
- 대기 시간을 최소화
- 응답시간을 최소화
### 스케줄링 큐들
- job queue : 모든 프로세스가 올라가 있는 큐 (Long term)
- ready queue : 준비 상태에 있는 큐들이 올라가 있다 (short term)
- device queue : 입출력 장치마다 있는것,
#### 큐잉 다이어 그램
큐, 자원(원모양),프로세스의 이동 흐름을 나타냄
![[assets/스크린샷 2024-04-16 오후 9.47.34.png]]
process create 되고 나선 바로 job queue에 적재된다.
이 적재된것중에 ready queue 로 가는 것
순서 : create > job queue > ready queue

## 스케줄러
### 단기 스케줄러 (= cpu 스케줄러) 
- 다음에 cpu에 할당될 프로세스를 선택한다
- 즉 준비큐에 있는 프로세스를 선택한다.
- ms 간격으로 호출 > 빨라야함

#### cpu 스케줄러가 실행되는 작업
- running -> wait 상태 전이 (비선점 방식)
- running -> ready 상태 전이 (선점 방식)
- wait -> ready 상태 전이 (선점방식)
- 종료 될 때 (비선점 방식)
- 선점 방식인 이유
	- 공유 데이터 접근 고려
	- 커널모드있는 동안의 선점 고려
	- os작업중에 인터럽트 발생 고려

#### dispatcher
단기 스케줄러가 선택한 프로세스에게 cpu 제어를 주는 모듈
- 하는 작업
	- 문맥교환
	- 사용자 모드로 전환
	- 프로그램을 다시 시작하기위해 사종자 프로그램의 적절한 위치로 이동
- 디스페처 지연
	- 디스페처가 하나의 프로세스를 중단시키고 다른 프로세스를 실행시키는데 소요되는 시간


### 장기 스케줄러 (= 잡 스케줄러)
- 준비큐로 이동할 프로세스를 선택한다.
- s, min 간격으로 호출
- 이 스케줄러가 다중프로그래밍 정도를 결정
- io bound 와 cpu bound프로세스가 고루 섞이도록 한다.
### 중기 스케줄러
- 많은 프로세스가 있을때(= 다중프로그래밍 중일 때), 너무 많은 프로세스에게 메모리를 할당해 시스템 성능이 저하 되는 것을 방지하기 위함
- swaping 이용
	-  물리 메모리 공간이 부족해지면, 물리 메모리의 확장 개념으로 swap area를 사용하고 swap out 시켜 내보냄
	- 메모리 <-> 디스크

## 스케줄링 알고리즘
### FCFS(first come, first served)
- 걍 queue
- 딱 시작하는 타이밍이 waiting 시간
- 호위효과가 발생할 수 있음
	- 모든 프로세스가 긴프로세스하나가 cpu를 양도하기를 기다리는 것
### priority 스케줄링
우선순위가 먼저인 것을 머저 할당
아래는 우선순위가 cpu burst 시간인 경우이다
- SJF(shortest job first)
	- 버스트 길이를 기준으로 가장 짧은 시간을 가진 프로세스를 스케줄
	- 언제나 최소의 평균 대기시간을 보장
	- 단기 스케줄러에서 구현 못함
	- BUT, CPU 버스트 시간을 알기 어렵다.
	- 대략 예측 방법
		- t(n) : n번째 프로세스 실제 CPU 사용 시간
		- 타우 n+1 : (n+1)번째 프로세스 CPU 사용 시간 추정치
  ![[assets/스크린샷 2024-04-17 오후 4.56.05.png|300]]
- SRTF(shortest remaining time first)
	- 선점 방식
	- 진행하다가 그 시간에 bursttime이 더 짧은 프로세스가 오면 선점함
	- 대기시간 = 마지막 조각 프로세스가 실행한 시간 - 프로세스도착시간 - 이전에 다른 조각프로세스가 실행한 시간

#### 문제/해결책
- starvation : 낮은 우선순위 프로세스는 실행되지 않을 수 있다.
- aging : 시간이 흘러갈수록 프로세스의 우선순위를 증가시킨다.
### RR(round robin)
- 선점형
- 프로세스는 적은양의 cpu 시간을 할당 받음(time quantum)
	- 시간이 경과할때마다 인터럽트
- if 준비큐에 n개, 시간할당량 q, 각프로세스는 q(n-1) 이상을 대기하지 않음
	- q가 커질수록 FIFO에 가까워짐
	- q가 적어지면 오버헤드가 커짐 so 문맥교환시간에 비해서는 충분히 커야함
![[assets/스크린샷 2024-04-17 오후 5.30.48.png|400]]

### multilevel queue
ready queue를  여러개로 분할
프로세스는 지정된 큐에 영원히 존재 (와리가리 못침)
큐 사이의 스케줄링도 정해야함

#### 대표적인 분할하는 queue
- foreground queue
	- user과의 상호작용을 많이하는 프로세스 존재
	- 보통 cpu 시간의 80퍼를 받아 RR방식으로 스케줄링
- background queue
	- user와 멀리떨어진 batch system형태의 프로세스 존재
	- 보통 cpu시간의 20퍼를 받아 FCFS 방식으로 스케줄링
- foreground queue 처리후 background queue고려 
  -> starvation 야기 -> cpu 시분할을 통해 방지
### multilevel feedback queue
각 프로세스가 여러 큐로 이동할 수 있다.
aging기법을 다음과 같은 방식으로 구현할 수 있음
응답속도가 빨라짐
![[assets/스크린샷 2024-04-17 오후 5.42.45.png|400]]
1. 먼저 quantum 8(RR방식)의 큐에 넣는다
2. if 위의 큐에서 처리안되면, 하위큐에 넣음
3. 최종적으로도 처리 안될 시 FCFS에 들어가서 처리됨
### multiple proceesor schduling(smp)
ex) NUMA![[assets/스크린샷 2024-04-17 오후 6.09.25.png|400]]
- cpu가 여러개
- 다중처리기 접근
	- 비대칭 다중처리 : 오직 하나의 처리기 만이 시스템 자료구조에 접근가능
	- 대칭 다중처리 : 각처리기는 독자적으로 스케줄링, 모든 프로세스는 각각이나 공통의 준비큐에 있을 수 있다.
- 처리 친화성 : 프로세스는 현재 자신이 실행중인처리기를 더 선호한다(당연한거아뉨?)
- 효율적으로 작동할라면 로드밸런싱이 있어야한다
	- push migration : 각처리기의 부하를 점검하고 일을 분배
	- pull mirgration : 노는 처리기가 바쁜 처리기에서 대기중인 일을 가져와 실행
### multicore processors
- 한 물리적칩안에 여러개의 처리기 코어를 배치
- 빠르며 더 적은 전력을 소모
- 코어마다 여러 스레드 지원이 증가하는 추세
- 메모리 멈춤 상황이 발생할 수 있음(여러프로세스가 메모리에 접근

### real-time cpu 스케줄링
Real-Time System은 "Deadline"이 존재하고 해당 Dealine을 지키지 않는다면 시스템에 치명적인 영향을 줄 수 있다. 그래서 반드시 "Deadline"내에 job을 끝내야 한다
- 선점형, 우선순위 기반(prioriy-based) 스케줄링을 지원해야함
- 마감시간을 충족해야한다
#### deadline
![[assets/스크린샷 2024-04-17 오후 6.16.55.png|400]]
- soft real time : 중요한 실시간 프로세스가 언제 스케줄될지 보장 ㄴㄴ
- hard real time : 테스크는 마감시간 전 까지 반드시 완료
- ==RMS (Rate Montonic Scheduling)==
	- 우선순위가 주기의 역수로 매겨짐
	- 즉, 빠른(적은)주기== 높은우선순위
	- ex) P1은 주기가 50초이고, 20초동안 processing한다. P2는 주기가 100초이고, 35초동안 processing한다
		![[IMG_0039.png]]
- ==EDF(Earliest Deadline First Scheduling)==
	- 우선순위가 마감시간에 따라 부여됨
	- 이 방법은 RMS처럼 static하게 priority를 주는 것이 아니라, task들이 들어올때마다 deadline을 비교해보고, priority를 정하는 방식이다
#### 지연시간
deadline을 지킬려면 지연시간을 최소화 해야함
두종류의 지연이 성능에 영향을 준다
- 인터럽트 지연 : 인터럽트가 도착해서 인터럽트를 서비스하기 시작할 때까지의 시간
- 디스패치 지연 : 프로세스를 중단시키고 새로운 프로세스로 전환하는데 걸리는시간(문맥전환)
	- 충돌이 될 수 있는 단계
		- 커널 모드에서 실행중인프로세스 선점
		- 낮은 우선순위의 프로세스가 높은 우선순위의 프로세스가 요구하는 자원을 방출

## 알고리즘 평가
### 결론적 모델링
특정 예측된 부하를 미리 정해 놓고 그 부하에 대한 각 알고리즘의 성능을 측정한다
- 분석적 평가의 한 부류
- 간단하고 빠르지만 특수한 입력에 대해서만 해당될 수 있음

### queueing model
- 프로세스 도착과 cpu,i/o 버스트를 확률적 분포를 설명
	- 평균 처리량, 이용률, 대기시간 등을 계산
- 각 서버는 대기 프로세스르 넣을 큐를 가진다
- little's law
	- n = 람다 * W (사실상 거속시아님?)
	- n : 평균 큐의  길이(몇개의 프로세스가 존재 가능하냐)
	- 람다 : 큐에 평균적으로 도착하는 평균 개수
	- W : 큐에서 평균적으로 기다리는 시간

### simulation
컴퓨터 시스템의 프로그램 모델
- 클럭은 가변적
- 알고리즘 성능을 나타내는 통계자료를 수집
- 데이터 수집 방법
	- 확률에 기초한 랜덤넘버 발생
	- 수학적 or 경험적으로 정의된 분포
	- 실제 시스템의 이벤트를 차례대로 기록한 추적테이프
- 위에것들보단 정확하지만 한계는 있다