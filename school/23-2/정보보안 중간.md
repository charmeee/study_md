식 정리
CBC
![[스크린샷 2023-10-24 오후 11.52.37.png|500]]
CTR
![[스크린샷 2023-10-24 오후 11.55.11.png]]
### 배낭
#### 키 세팅 과정 
- 수퍼증가 배낭 선정 // (2, 3, 7, 14, 30, 57, 120, 251) 로 정함
- 서로소인 m, n 선정 (n> 수퍼배낭 전체합) // m=41, n=491
	-  개인키 n & x= m^-1 mod n // m * x = 1 mod n  여기서 x가 
- 수퍼배낭요소 * m mod n = 일반 배낭요소<<좀외워라
	- (82, 123, 287, 83, 248, 373, 10, 471)
#### 암호화
- 평문 -> 8자리 이진수 //150
- 해당하는 위치(1인)에 있는 수퍼배낭요소를 더함  //548
- 암호화 값 548
#### 복호화
- 암호화 값 * 개인키x mod 개인키 n // 548 * 12 mod 491 = 193
- 수퍼배낭에서 골라서 위의 결과 값이 나오는지 찾아봄 
- 선택된것 1 아닌것  0

### RSA
#### 키 셋팅 과정
- 소수 p ,q 선정 //p = 11, q = 3
- N= p*q  //33
- (p−1)(q−1)과 서로소인 e 선정 //3
- e * d  = 1 mod 20 을 만족하는 d를 찾으쉠 // d =7
- 공개키 : (N,e) // (33, 3)  , 개인키 : d // 7

#### 암호화
- if M = 15
- C = M^e mod N = 9
#### 복호화
- M= C^d mod N =15

### 디피  헬먼
- x = g^k mod p // g를 생성자 or 원시근이라고 함
## 정보보안  기본
### 정보보안 3대 요소
- 비밀성 : 허가 x -> 읽기 방지
- 무결성 : 허가 x -> 쓰기 변경 방지
- 가용성 : 허가 x -> 
- 암호화 자체로 무결성 확신 불가능 ,비밀성은 제공

### 접근제어
- 인증 : 허가된 사람인가?를 확인하는 과정
- 인가 : 허가된사람의 행동을 통제

### 커크호프 법칙
- 암호체계 자체는 비밀이아니다
- 키만이 유일한 비밀

### 새넘
 - 혼돈 : 암호문과 평문의 상관관계를 숨김
 - 확산 : 평문의 통계적 성질을 없앰


## 고전암호

#### 단순치환
- 종류 : n shift(카이사르 암호), 순열
- 장점 : 가장 간단
- 단점 : 통계 분석 쉬움

#### 이중전위
- 행과 열을 바꿈
- 장점 : 통계적 공격 방지 ( 확산 만족 )

#### 일회용
- 암, 복호화 과정이 같음 (XOR 이용)
- msg length == key length
- 한번만 사용
- 암호자체에서 얻는 정보 ㄴㄴ
- 장점 : 이론적으로 가장 안전함
- 단점
	- 여러번 쓸 수 없음 (두개 걍 xor때리면 키가사라짐)
	- 키를 계속 안전히 전달 할 수 없음

#### 코드북
- 단어단위로 치환

## 대칭키

### 스트림 암호
- 일회성방식(xor)
- 긴 키스트림 사용
- only 혼돈
#### A5/1
- 3개 shift(19,22,23 / LFSR) 사용
- 총 64 bit
- 하드웨어 기반
-  gsm 휴대폰에 사용
- 각단계마다 1bit 씩 생산
#### RC4
- s/w 기반
- 자체 변경 lookup table
- 각 단꼐 1byte 씩 생산
- SSL에도 사용 
- 8비트 처리장치에 적합

### 블록 암호
- 코드북 방식(고정된 크기 블록)
- 혼돈 & 확산
- 라운드
- 주로 S/W
#### 페이스텔 구조
- L,R 평문을 나눔
  ![[스크린샷 2023-10-24 오후 9.30.45.png|500]]
##### DES
- 64 bit block
- 16round
- key56bit -> 48bit
- 안정성 S-box에 의존
- 백도어 x -> 안전
- C = E( P , K ) ,  P = D( C , K )
- 키스트림을 늘리기위해서 3DES 사용
	- C = E( D ( E ( P , K1 ) , K2 ) , K1)
	- P = D( E ( D ( C , K1 ) , K2 ) , K1)
	- C = E( E(P, K1), K2)로 생성하지 않는 이유
		- 알려진 평문공격
			- 모든 가능한 K1에 대한 E(P, K1)의 테이블(256개) 작성
			- 모든 가능한 K2에 대한 D(C, K2)의 테이블(256개) 작성
			- 두 테이블에서 서로 같은 값을 가지는 요소(E(P, Ki)) == D(C, Kj) 를 발견하면, 이 Ki, Kj가 K1, K2가 됨.
##### TEA
- 64bit block,128 bit key
- 32bit 연산 컴퓨터 적당
- 라운드 수 가변적 (32회 보통)
- 간단한 라운드 함수 , 많은 라운드 수
- 구축 쉬움
- 적은 메모리 but 빨라야함(비용이좀비쌈)
- 취약점 : 관련 키공격이 가능


#### 페이스탈 X
##### AES
- DES를 대치
- 블록크기 128,192,256 지정가능
- 키 깊이 128,192,256 (블록 크기와 독립)
- round : 10 ~ 14
- round 함수 : 4개 , 계층은 3개
	- byteSub(비선형) : S-box 역할
	- shiftRow(선형) : 이중전위
	- MixColomn(비선형) : 룩업테이블, shift & xor
	- AddRoundkey: 키스케줄, xor

#### 운용모드
##### ECB
- 각 블록을 동일키로 암호화
	- 동일한 P = 동일한 C
	- 복붙 공격 가능 ( 무결성 down)
##### CBC
- 블록을 체인처럼 연결
- 안전함 , 추가작업 적음
- 임의의 vector IV 활용 , 비밀아니어도됨
- 동일한 P ≠ 동일한 C ( 무결성)
- 같은 평문블록도 다른 암호문 블록생산
- 복사 붙여넣기 공격 빡셈
![[스크린샷 2023-10-24 오후 11.52.37.png|500]]
##### CTR
- 키스트림을 블록암호로
- 임의접근에 많이 사용 (CBC는 임의접근 안됨)
![[스크린샷 2023-10-24 오후 11.55.11.png]]

##### MAC
- CBC의 나머지로 계산
- 오류가 전파됨
![[스크린샷 2023-10-24 오후 11.57.55.png|500]]

## 공개키 암호
- 한쌍의 키 : 공개키,비밀키 사용
- 트랩도어라는 단방향 함수를 기반
- 암호화 : C = { M }앨리스 // 앨리스의 공개키로 M암호화
- 복호화: M = [ C ]앨리스 //앨리스의 개인키로 복호화
- 서명 : S = [ M ]앨리스 // 앨리스의 개인키로 서명
	- 부인봉쇄를 제공
		- 내것이 아니라고 부인하는것을 봉쇄할 수 있음
		- 누구 발 데이터인지알 수 있음
	- 선 서명 후 암호화
		- 보내는 사람은 정해지는데 받는사람은 몰루?
	- 선 암호화 후서명
		- 서명을 벗겨내어 다시서명할 수 있다.
- PKI : 공개키를 안전하게 사용하기위한 기반 체계
- 전자 인증서
	- 사용자의 공개ㅣ와 이름을 포함
	- 인증기관 (CA) 서명

### 배낭암호
1. 수퍼증가 배낭 생산
2. 수퍼배낭을 일반 배낭으로 전환 
- 공개키 = 일반배낭
- 개인키 = 수퍼증가 배낭과 변환 인수들
#### 키 세팅 과정 
- 수퍼증가 배낭 선정 // (2, 3, 7, 14, 30, 57, 120, 251) 로 정함
- 서로소인 m, n 선정 (n> 수퍼배낭 전체합) // m=41, n=491
	-  개인키 n & x= m^-1 mod n // m * x = 1 mod n  여기서 x가 
- 수퍼배낭요소 * m mod n = 일반 배낭요소
	- (82, 123, 287, 83, 248, 373, 10, 471)
#### 암호화
- 평문 -> 8자리 이진수 //150
- 해당하는 위치(1인)에 있는 수퍼배낭요소를 더함  //548
- 암호화 값 548
#### 복호화
- 암호화 값 * 개인키x mod 개인키 n // 548 * 12 mod 491 = 193
- 수퍼배낭에서 골라서 위의 결과 값이 나오는지 찾아봄 
- 선택된것 1 아닌것  0


### RSA
- 오일러 정리 사용
#### 키 셋팅 과정
- 소수 p ,q 선정 //p = 11, q = 3
- N= p*q  //33
- (p−1)(q−1)과 서로소인 e 선정 //3
- e * d  = 1 mod 20 을 만족하는 d를 찾으쉠 // d =7
- 공개키 : (N,e) // (33, 3)  , 개인키 : d // 7

#### 암호화
- if M = 15
- C = M^e mod N = 9
#### 복호화
- M= C^d mod N =15

![[스크린샷 2023-10-25 오전 11.22.27.png]]


### 디비 헬펀
- 키 교환 알고리즘
- 보안성은 이산로그 문제의 난이도에 기반
	- x = g^k mod p // g를 생성자 or 원시근이라고 함
	- p와 g를 공개
	- p=353 , g=3 / k: a= 97, b= 233
		- a 전송값 : g^97 % 353 = 40
		- b 전송값 : g^233 % 353 = 248
		- 공유키 : a: 248^97%353 = b: 40^233 %353 = 160
	- 중간자 공격에 취약
		- DH 교환값을 서명 or 공개키로 교환값을 암호화
- 타원곡선 임마기반.

## 해쉬 함수
- 어떤 데이터를 상대적으로 작은 숫자로 매핑하는 함수
- 쇄도 효과 ( 작은 변경이 큰 변경을 유래)
- 보안 속도
- 여러개의 round로 구성
- 조건
	- 압축
	- 효율성
	- 단방향
	- 약한 충돌 방지 : x, h(x) 에대해 h(x)=h(y)에 대해 서로다른 x,y찾기 어려워야함
	- 강한 충돌 방지: h(x)=h(y)에 대해 그어떤 서로다른 x,y찾기 어려워야함
- 널리 사용되는 hash
	- MD
	- SHA : 미정부 표준 512 입력 ,160 출력
- 용도
	- 패스워드 보관
	- 무결성
	- 전자서명효율성
	- ex ) 온라인 입찰
		- 입찰 
		- 금액공개는 ㄴㄴ 해쉬값만 공개
		- 낙찰
		- 낙찰후 금액공개
		- 가격변경하엿다는 의심을 지울 수 있음
### 비암호 해쉬
- hash(X) = X0+X1+X2+…+Xn-1
	- 충돌찾기 넘나쉬움
- CRC h(X) = n * X0+(n-1) * X1+(n-2) * X2+…+1 * Xn-1 mod 256
	- 단방향 성직 만족 ㄴ
	- 전송오류 찾는데 사용

### tiger
- 64-비트 프로세스에서 가장 효율적
- 중간 회전 ,출력 192bit
- 4개의 s 박스
- 키스케줄
- 

### HMAC
- 해쉬된 mac